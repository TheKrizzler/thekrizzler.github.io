---
layout: writeup
title: "Hunting my first CVE - Part 1"
category: real
difficulty: real
tags: [rev, web, crypto, real, CVE]
date: 2025-11-29
---

## Background

For a while I have been wanting to work towards my first CVE. I imagine this is a good milestone when moving from CTF challenges to real exploitation. In the beginning I will approach this fairly naively by just analyzing binaries manually, but if I don't have any luck I might move onto techniques like fuzzing. 

On black friday I took a trip to my local electronics store and one particular product caught my attention. The incredible ASUS RT-N12E router, at a whopping 30$. Considering the potential vulnerabilities this thing could have, I simply could not resist.  

![Picture of router box](/images/cve_hunt_1_router.jpg)

In this series I will be documenting my findings in attempting to reverse engineer the firmware and hopefully finding one or more exploitable vulnerabilities.

*Disclaimer: I did consider that this project may have legal implications. To be clear, I am only doing this for educational purposes. If I manage to successfully exploit something, it will be responsibly disclosed.*

## Initial findings

It turns out that this router is fairly easy to work with when it comes to analysis. The router provides you with ssh access, so you can dump any file directly from it without any need for complicated firmware dumping. ASUS also provides images of different versions of the firmware online, and to top it all off, the firmware for this router seemed to be open source.

As the open source code seemed to belong to this exact model, I immediately got to work on analyzing the it for potential vulnerabilities. More specifically, I wanted to find one of two things: an authentication bypass, which leads to full RCE as root by adding your ssh key, or a memory error which could potentially be converted to RCE. To start off, I visited the webpage as it likely has a big attack surface.

## Potential token forgery?

After logging in as admin and inspecting the traffic, I poked around looking for low hanging fruit like XSS or LFI where it seemed possible. While it didn't seem completely unplausible, it wasn't exactly what I was looking for. I decided at some point to go deeper into the session token generation once i spotted the `asus_token` cookie.

![Picture of server response](/images/cve_hunt_1_token.png)

When the user logs in, a POST request is sent to /login.cgi, which handles the generation of the session token if the credentials are correct. It took some time to find the login handler and go through the functions, but finally I found the function responsible for generating tokens. Remember, this function needs to generate cryptographically secure, unguessable, and unbreakable tokens. This function is what stands between an arbitrary user on the network and full root access to the router.

```c
char *generate_token(void){

	int a=0, b=0, c=0, d=0;
	//char create_token[32]={0};

	memset(gen_token,0,sizeof(gen_token));
	srand (time(NULL));
	a=rand();
	b=rand();
	c=rand();
	d=rand();
	snprintf(gen_token, sizeof(gen_token),"%d%d%d%d", a, b, c, d);

	return gen_token;
}
```

What? Is this a joke? This genuinely looks like an easy-difficulty ctf challenge.  

The function uses the srand function to seed the random number generator, and then generates four random 32-bit numbers and simply concatenates them to make the session token. The seed used is `time(NULL)` which gets the current time as a unix timestamp. This means that the final session token is **entirely** dependent on *when* it was generated, meaning all you would need to forge a valid session token is knowing exactly when one was generated.  

At this point I really thought I had hit the jackpot. But something was off, and it sounded a bit too good to be true. First, I needed to address the elephant in the room. Why was my token base64 encoded, when this function clearly says the token is just a sequence of numbers? In the login handler, I did not see any base64 involved in the token generation.  

## Grave mistake \#1

I may have been a bit eager to get started, as I forgot to verify that my router was using the same version as the version in the source code. The open source code was from version `3.0.0.4.380.6042`, but my router was running version `3.0.0.4.380.10809` (which supposedly doesn't even belong to my particular model but whatever). I could not find any open source code for my version, which means we are gonna have to work with decompilers moving forward.  

Checking out the `generate_token` function in the correct version reveals a fix which makes token generation far more secure, utilizing `/dev/urandom` for random bytes.

```c
char *generate_token(char *token, int token_len){
...
  urandom_fp = fopen("/dev/urandom", "r");
  if (urandom_fp == 0) {
...
  } else {
      for (i = 0; i < token_len - 1; i++) {
        read_result = fread(buffer,1,1,urandom_fp);
...
```

## Summary

Even though I didn't yet find anything useful for my particular router, I'm still glad I identified this massive security flaw so quickly. If it was relevant to my router, I would still have to find a way to consistently exploit it to consider reporting it as a CVE. I'm sure I could keep working on this vulnerability and change the firmware on my router to that older version, but ideally I want to be able to exploit the router exactly the way it came, out of the box. Therefore, I won't be pursuing this any further for now.

From here, I will dig deeper into the authentication, and potentially look for memory leaks. As most of the code is written in C, there is a lot of potential for bugs in data parsing and such.

/Kriz